#include "hal_data.h" // Inclusión de bibliotecas para configuración del hardware
#include "hal_entry.h" // Biblioteca de entrada principal de hardware
#include "ini_interrupt.h" // Inicialización de interrupciones
#include "ADC_pot.h" // Biblioteca para el control del ADC del potenciómetro
#include "I2C_master.h" // Controlador maestro I2C
#include "UART_config.h" // Configuración de UART
#include <stdio.h> // Biblioteca estándar de E/S
#include "r_adc_api.h" // API para el control del ADC
#include "r_iic_master.h" // Controlador maestro IIC

// Cabeceras y pies de página para C++ en entornos FSP
FSP_CPP_HEADER
void R_BSP_WarmStart(bsp_warm_start_event_t event);
FSP_CPP_FOOTER

// Definición de variables para la comunicación con el display LCD
uint8_t line1[0x02]={0x00, 0x80}; // Dirección de la primera línea del display LCD
uint8_t line2[0x02]={0x00, 0xC0}; // Dirección de la segunda línea del display LCD

// Variables para mensajes en el display
uint8_t msg_value[0x09]; // Buffer para el mensaje con el valor del potenciómetro
uint8_t msg_on[0x09]={0x40, 0x53, 0x59, 0x53, 0x54, 0x45, 0x4D, 0x4F, 0x4E}; // Mensaje "SYSTEM ON"
uint8_t msg_danger[0x09]={0x40, 0x50, 0x45, 0x4C, 0x49, 0x47, 0x52, 0x4F, 0x80}; // Mensaje "PELIGRO"
uint8_t msg_empty[0x09]={0x40, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80}; // Mensaje vacío para limpiar display

// Variables de control de estado
bool timer = false; // Estado del temporizador (activado/desactivado)
bool led_nivel = false; // Estado del LED (encendido/apagado)
bool warning = false; // Estado de alerta (activo/inactivo)
bool btn = false; // Estado del botón (presionado/no presionado)

// Filtro de promedio móvil
int avg_filter[5] = {0}; // Filtro de promedio para suavizar valores del ADC
int filter_index = 0; // Índice actual en el filtro de promedio móvil
uint16_t avg = 0; // Valor promediado actual del ADC
uint16_t prev_avg = 0; // Valor promediado anterior del ADC

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    // Inicializaciones de las variables y funciones
    ADCInit();
    init_i2c();
    clear_i2c();
    initialize_LCD();
    init_uart();
    fsp_err_t err = R_GPT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    // Maneja cualquier error. Esta función debe ser definida por el usuario.
    assert(FSP_SUCCESS == err);

    // Inicialización del driver IRQ
    err = icu_init();
    // Handle error
    if(FSP_SUCCESS != err)
    {
        // Fallo inicialización
    }

    // Habilitar el IRQ driver
    err = icu_enable();
    // Handle error
    if(FSP_SUCCESS != err)
    {
       // Cerrar el modulo IRQ
       icu_deinit();
    }

    // Inicialización del módulo IOPORT y configurar los pines
    err = R_IOPORT_Open(&g_ioport_ctrl, &g_bsp_pin_cfg);
    assert(FSP_SUCCESS == err);
    // Configurar Pin como salida
    // Llamar al R_IOPORT_PinCfg si la configuración no formaba parte de las configuraciones iniciales realizadas en open
    err = R_IOPORT_PinCfg(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_06, IOPORT_CFG_PORT_DIRECTION_OUTPUT);
    assert(FSP_SUCCESS == err);
    err = R_IOPORT_PinCfg(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_13, IOPORT_CFG_PORT_DIRECTION_OUTPUT);
    assert(FSP_SUCCESS == err);

    // Loop hasta que se pulse el botón
    while (1) {
        if (btn) {
            // Iniciar el temporizador
            (void) R_GPT_Start(&g_timer0_ctrl);

            // Valor potenciómetro
            uint16_t adc_result;
            char str[5]; // Cadena que contiene el valor

            // Loop
            while (1)
            {
                // Realizar la lectura del potenciómetro
                ADCStartScan();
                ADCWaitConversion();
                adc_result = ReadADC(ADC_CHANNEL_4);
                // Actualizar el filtro de media móvil
                update_filter(adc_result);

                // Cuando se acaba el tiempo establecido en el timer:
                if (timer)
                {
                    // Cálculo del valor del potenciómetro sin ruido
                    avg = calculate_avg();

                    // Convertir el número a un string
                    sprintf(str, "%i", avg);
                    // Enviar valor por UART
                    uart_write(str);

                    // Comprobar si el valor se encuentra en el 75% del máximo
                    if (avg > 16383*0.75)
                    {
                        // Checkear estado del zumbador e invertir su estado y si se ha entrado en el modo de emergencia para que solo se active una única vez
                        if (warning)
                        {
                            // Escribimos el valor "low" al pin 113
                            err = R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_13, BSP_IO_LEVEL_LOW);
                        }
                        else
                        {
                            // Escribimos el valor "high" al pin 113
                            err = R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_13, BSP_IO_LEVEL_HIGH);
                            // Como ya ha zumbado invertimos la variable warning
                            warning = true;
                        }
                        assert(FSP_SUCCESS == err);

                        // Llamada a la función de freno de emergencia
                        emergency();
                    }
                    else
                    {
                        // Escribimos el valor "low" al pin 106
                        err = R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_06, BSP_IO_LEVEL_LOW);
                        assert(FSP_SUCCESS == err);
                        led_nivel = false;
                        // Escribimos el valor "low" al pin 113
                        err = R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_13, BSP_IO_LEVEL_LOW);
                        assert(FSP_SUCCESS == err);

                        // Cambiamos a FALSE la variable asignada al estado de emergencia
                        warning = false;

                        // Enviar y mostrar el mensaje SYSTEMON al display
                        write_LCD(line1, msg_on);
                        // Borrar la segunda línea del display
                        write_LCD(line2, msg_empty);
                    }

                    // Cambiar a FALSE la señal que indica que el temporizador está activo
                    timer = false;
                }

                // Delay de 100ms
                R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
            }
        }
        // Delay de 100ms
        R_BSP_SoftwareDelay(100, BSP_DELAY_UNITS_MILLISECONDS);
    }


#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

/**************************************//*
 * This function is called at various points during the startup process.  This implementation uses the event that is
 * called right before main() to set up the pins.
 *
 * @param[in]  event    Where at in the start up process the code is currently at
 ****************************************/
void R_BSP_WarmStart(bsp_warm_start_event_t event)
{
    if (BSP_WARM_START_RESET == event)
    {
#if BSP_FEATURE_FLASH_LP_VERSION != 0

        /* Enable reading from data flash. */
        R_FACI_LP->DFLCTL = 1U;

        /* Would normally have to wait tDSTOP(6us) for data flash recovery. Placing the enable here, before clock and
         * C runtime initialization, should negate the need for a delay since the initialization will typically take more than 6us. */
#endif
    }

    if (BSP_WARM_START_POST_C == event)
    {
        /* C runtime environment and system clocks are setup. */

        /* Configure pins. */
        R_IOPORT_Open (&g_ioport_ctrl, g_ioport.p_cfg);
    }
}

#if BSP_TZ_SECURE_BUILD

BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
#endif

// Button callback function
void interrupcion_boton(external_irq_callback_args_t *p_args)
{
    // Indica que el pulsador se ha presionado
    btn = true;
}


// Esta función se llama cada vez que se lee un valor nuevo del potenciómetro.
void update_filter(uint16_t x)
{
    // Asigna el nuevo valor del potenciómetro al filtro de media móvil
    avg_filter[filter_index] = x;
    // Incrementa el índice del filtro de media móvil, si llega a la última posición se vuelve al inicio
    filter_index = (filter_index + 1) % 5;
}


// Invierte el estado del LED, muestra el valor del potenciómetro y un mensaje de peligro en el display
void emergency(void)
{
    fsp_err_t err;
    // Comprobación del estado del LED e invertir su estado
    if (led_nivel)
    {
        // Escribimos el valor "low" al pin 106
        err = R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_06, BSP_IO_LEVEL_LOW);
        led_nivel = false;
    }
    else
    {
        // Escribimos el valor "high" al pin 106
        err = R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_06, BSP_IO_LEVEL_HIGH);
        led_nivel = true;
    }
    assert(FSP_SUCCESS == err);

    // Comprobar si el valor previo y el actual no son iguales
    if (prev_avg != avg)
    {
        parse_value(avg); // Cambio a formato ascii al valor del potenciómetro
        write_LCD(line1, msg_value); // Enviar y mostrar el valor al display
    }

    // Enviar y mostrar el mensaje "PELIGRO" al display
    write_LCD(line2, msg_danger);

    // Actualizar el valor previo
    prev_avg = avg;
}


// Se elimina el ruido del valor del potenciómetro al calcular la media de los últimos valores del filtro de media móvil
int calculate_avg()
{
    int sum = 0; // Inicialización de variable para la suma de los valores del filtro de media móvil

    // For para recorrer los valores del filtro de media móvil
    for (int i = 0; i < 5; i++)
    {
        // Adición los valores del filtro
        sum += avg_filter[i];
    }
    // Return media de los 5 últimos
    return sum / 5;
}


// Transforma un número a código ascii y lo muestra en la primera línea del LCD
void parse_value(uint16_t value)
{
    char str[8]; // Array de 8 caracteres
    char numero_char; // Número del array que contiene el número completo
    unsigned char asciiValue; // Valor ascii de la cifra

    // Convertir el número a un string
    sprintf(str, "%i", value);

    // Asignar el item [0] del array a 0x40 para indicar que es de escritura
    msg_value[0] = 0x40;
    // For para recoger los elementos del string anterior
    for (int i = 0; i < 8; i++)
    {
        // Comprobación de si el string es menor a la longitud total del array (si hay items no numéricos)
        if (str[i] >= '0' && str[i] <= '9')
        {
            // Cambio de la cifra del array a formato ascii y envío al display
            numero_char = str[i];
            asciiValue = (unsigned char)numero_char;
            msg_value[i+1] = asciiValue;
        }
        else
        {
            // Envío de una cifra vacía al display
            msg_value[i+1] = 0x80;
        }
    }
}


// Función de callback del temporizador
void timer_callback(timer_callback_args_t *p_args)
{
    // Esta función se llama en función del periodo acutal
    if (TIMER_EVENT_CYCLE_END == p_args->event)
    {
        // Set a TRUE en la variable que muestra que el temporizador se ha activado
        timer = true;
    }
}
